We plan to implement MABE 2.0 using Empirical.

What might this look like?

Our goal is to have a set of components that have a common interface and easily plug together.
These include:

* Brains (Controllers? or simply Control Modules, since multiple ones can plug togeter?)
* Genomes
* Worlds (Environments)
* Archivsts (Listeners? Recorders?)
* Selection Scheme (Update Schema?)

An organism is zero or more brains and zero or more genomes.
...this arrangement should be doable with templates...

Brains can emit signals and can listen for signals of pre-specified types.
(these are actions and sensors, respectively)

Similarly Worlds can emit signals (events) and listen for signal (responding to actions).

By default, these are hooked together automatically.

What might this look like?  Well, first, we'll build an org:

  using org_t = mabe::Organism<mabe::MarkovBrain, mabe::LinearGenome>;

We should be able to plunk this into any world type.  In Empirical, we would do this with:

  emp::World<org_t> world;

But in that case a World and Environemnt are separate.  What if we stick with that, though?
As long as environemnts have a fixed API, we could just use:

  world.SetupEnvironment(my_env);

This sertup would automatically build the patch board for the organism and fill it out in
some reasonable way by default.

Alternatively, if we want to do as much as possible at compile time, we could instead expand
the world and include the environment right there along with whatever org types we need.

  emp::World<org1_t, org2_t, env_t> world;

The advantage of method 1 is that it makes it easier to setup an environment in code before
handing it over to the world.  The advantage to method 2 is that it allows the world to be
able to more deeply examine an environment to, for example, make sure the config object is
handling it correctly without any extra effort on the part of the library user.


The last two components of a MABE run are Archivists and Selection Mechanisms.

In principle, I think Archivists cover everything that doesn't feed back into a run (and
hance propose a re-name to Listeners), while Selection Mechanisms describe how a run should
be advanced over time (and not limited to synchronous generations as they are in MABE 1.0),
thus we could call them Update Schema.


As such, there would be four high-level interchangable components in MABE 2.0:

* Organisms (which are built from controllers and genomes, also with a rigid interface)
* Environments (which can have common sub-parts, such as grids, continuous, etc.)
* Listeners (such as systematics trackers or other data management techniques)
* Update Schemas (selection techqniues, mutations, etc; can be applied in sets or bundled)


Given all of this, we might setup a MABE run as:

  int main(int argc, char * argv[]) {
    // Determine the types of everything that you want to use to build the world.
    using sheep_t = mabe::Organism<mabe::MarkovBrain, mabe::LinearGenome>;
    using wolf_t = mabe::Organism<mabe::MarkovBrain, mabe::NetworkGenome>;
    using env_t = mabe::FarmEnvironment;
    using track_t = mabe::TrackLineage;
    using select_t = mabe::TournamentSelect;

    // Build the world using these types.  Giving it a config filename plus argv and argc
    // will allow it to process all configuration inputs.
    mabe::World<sheep_t, wolf_t, env_t, track_t, select_t> world("farm.cfg", argv, argc);

    // Running world will go for full configured duration; can also manually Update() it.
    return world.Run();
  }