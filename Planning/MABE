We plan to implement MABE 2.0 using Empirical.

What might this look like?

Our goal is to have a set of components that have a common interface and easily plug together.

In the current version of MABE the types of components are:

* Brains (Controllers? or simply Control Modules, since multiple ones can plug togeter?)
* Genomes (Representations?)
* Worlds (Environments?)
* Archivsts (Listeners? Recorders?)
* Optimizers (Selection Scheme? Update Schema?)

An organism has zero or more brains and zero or more genomes.
...this arrangement should be doable with templates to have all of this at compile time.
Indeed, other components (Worlds especially) could also contribute portions of an organism at compile time;
Bodies, for example, are NOT currently considered part of the organism because they are provided by the World;
it seems better to have a single class, if possible, that bundles all organism-related information.

The new version of brains will be able emit signals and can listen for signals of pre-specified types.
(these are actions and sensors, respectively)

Similarly Worlds can emit signals (events) and listen for signal (responding to actions).


What might this look like?  Well, first, we'll build an org:

  using org_t = mabe::Organism<mabe::MarkovBrain, mabe::LinearGenome>;

We should be able to plunk this into any world type.  In Empirical, we would do this with:

  emp::World<org_t> world;

But in that case a World and Environemnt are separate.  What if we stick with that, though?
As long as environemnts have a fixed API, we could just use:

  world.SetupEnvironment(my_env);

This sertup would automatically build the patch board for the organism and fill it out in
some reasonable way by default.

Alternatively, if we want to do as much as possible at compile time, we could instead expand
the world and include the environment right there along with whatever org types we need.

  emp::World<org1_t, org2_t, env_t> world;

The advantage of method 1 is that it makes it easier to setup an environment in code before
handing it over to the world.  The advantage to method 2 is that it allows the world to be
able to more deeply examine an environment to, for example, make sure the config object is
handling it correctly without any extra effort on the part of the library user.


The last two components of a MABE run are Archivists and Selection Mechanisms.

In principle, I think Archivists cover everything that doesn't feed back into a run (and
hance propose a re-name to Listeners), while Selection Mechanisms describe how a run should
be advanced over time (and not limited to synchronous generations as they are in MABE 1.0),
thus we could call them Update Schema.


As such, there would be four high-level interchangable components in MABE 2.0:

* Organisms (which are built from controllers and genomes, also with a rigid interface)
* Environments (which can have common sub-parts, such as grids, continuous, etc.)
* Listeners (such as systematics trackers or other data management techniques)
* Update Schemas (selection techqniues, mutations, etc; can be applied in sets or bundled)


Given all of this, we might setup a MABE run as:

  int main(int argc, char * argv[]) {
    // Determine the types of everything that you want to use to build the world.
    using sheep_t = mabe::Organism<mabe::MarkovBrain, mabe::LinearGenome>;
    using wolf_t = mabe::Organism<mabe::MarkovBrain, mabe::NetworkGenome>;
    using env_t = mabe::FarmEnvironment;
    using track_t = mabe::TrackLineage;
    using select_t = mabe::TournamentSelect;

    // Build the world using these types.  Giving it a config filename plus argv and argc
    // will allow it to process all configuration inputs.
    mabe::World<sheep_t, wolf_t, env_t, track_t, select_t> world("farm.cfg", argv, argc);

    // Running world will go for full configured duration; can also manually Update() it.
    return world.Run();
  }


Since we want existing components to be as easy to manipulate as possible, we want to also
be able to configure aspects of them in code.

For one, we should be able to access components of World from an object.  A simple way of
doing this is to store components as tuples and have templated accessors.  In the example
above, world.GetOrg<0>() could return the sheep prototype, while world.GetOrg<1> would 
return the wolf prototype.

Any updates to details may be needed to be done before the config object is accessed.  For
example, configuration groups may need to be named.

As such, if you build a world without any arguments, you can then run config later.

  mabe::World<sheep_t, wolf_t, env_t, track_t, select_t> world;
  world.NameOrgType<0>("Sheep");
  world.NameOrgType<1>("Wolves");
  world.Config("farm.cfg", argv, argc);

Even simpler is if we REQUIRE both names for each component type and for the configuration to occur second.
Then we would be able to have the names in the world constructor and write:

  mabe::World<sheep_t, wolf_t, env_t, track_t, select_t>
  world("Sheep", "Wolves", "FarmEnvironment", "LineageTracker", "TournamentSelection");
  world.Config("farm.cfg", argv, argc);

Knowing this additional information up front will allow us to use scoping in the configuration file.



Given the current thoughts, here's what a full file might look like:

  #include "mabe.h"
  #include "brains/MarkovBrain.h"
  #include "genomes/LinearGenome.h"
  #include "genomes/NetworkGenome.h"
  #include "environments/FarmEnvironment.h"
  #include "listeners/TrackLineage.h"
  #include "schemas/TournamentSelect.h"

  int main(int argc, char * argv[]) {
    // Determine the types of everything that you want to use to build the world.
    using sheep_t = mabe::Organism<mabe::MarkovBrain, mabe::LinearGenome>;
    using wolf_t = mabe::Organism<mabe::MarkovBrain, mabe::NetworkGenome>;
    using env_t = mabe::FarmEnvironment;
    using track_t = mabe::TrackLineage;
    using select_t = mabe::TournamentSelect;

    // Build the world using these types.
    mabe::World<sheep_t, wolf_t, env_t, track_t, select_t>
    world("Sheep", "Wolves", "FarmEnvironment", "LineageTracker", "TournamentSelection");

    // Configure the world using the "farm.cfg" file and command-line overrides.
    world.Config("farm.cfg", argv, argc);

    // Running world will go for full configured duration; can also manually Update() it.
    return world.Run();
  }
