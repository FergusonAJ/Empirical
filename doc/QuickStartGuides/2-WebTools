The web tools in Empirical are stuctured to allow the developer to fully control components of
a web page from C++.  Note that you must have the Emscripten compiler installed for web utilities
to function properly.

Empirical web Widgets include Text, Buttons, Images, Tables, or many other HTML components.
All widgets are derived from emp::Widget and structured such that multiple widgets can
properly refer to and modify the same component.  

=== A Simple Example ===

In order to get a simple example working, we need:
* An HTML file (the default version is effective in most cases)
* The C++ code file to actually control the web page
* The necessary flags to compile (again, the default version should work.

These can be found in examples/web/ in the files Example.html, Example.cc and Makefile.

Here is Example.html:

  <!doctype html>
  <html>
  <head>
  <meta charset="utf-8">
  <title>Example</title>
  </head>
  <body>
  <div id="emp_base"></div>
  <script src="jquery-1.11.2.min.js"></script>
  <script type="text/javascript" src="Example.js"></script>

  </body>
  </html>

The only portions of this file that need to be customized for your project are the title (what
Title do you want your web page to have?) and change Example.js to the name of the js file that
you want to generate.  The div (named "emp_base") is where we will hook Empirical to this web
page.  You MAY add more divs to control or customize any aspects of this file's CSS as well, but
none of this is required for developing an interface, and most of it can be controlled via C++.

Here is the Example.cc file:

  #include "web/web.h"

  namespace UI = emp::web;

  UI::Document doc("emp_base");

  int main() {
    doc << "<h1>Hello World!</h1>";
  }

This setup will create a web page the says "Hello World!" in large letters.  Manipulations to
doc will allow us to control many portions of the web page.  To break down what's going on,
including "web/web.h" pulls in Empirical's web framework.  Setting the namesapce to "UI"
provides a shorter prefix for accessing widgets.  Creating the "doc" Document object attaches
to the div by the same "emp_base" name in the HTML file.  Note the doc is global because we
want the web page to keep functioning after main() finishes.  In Emscripten, main() is like any
other function and does not force the termination of the execution.

Now that we have the two files we need, the only other thing we need to do is compile.  The
provided Makefile can be run by typing "make Example.js".  This will trigger:

  emcc -std=c++14 -Wall -Wno-unused-function -I../../source/ -Os -DNDEBUG
  -s TOTAL_MEMORY=67108864 --js-library ../../source/web/library_emp.js
  -s EXPORTED_FUNCTIONS="['_main', '_empCppCallback']" -s NO_EXIT_RUNTIME=1
  Example.cc -o Example.js

Emscripten uses the emcc compiler (or "em++", since we are using C++).
 -std=c++14 : Empirical requires c++14
 -Wall -Wno-unused-function : turn on all warnings by default except for unused functions,
    since not all library functions are going to be used.
 -I../../source/ : The compiled file is two directories up in the Empiricial library, so 
    this flag properly includes the source files.
 -Os : optimize for size, though -O3 may perform better in some situations
 -DNDEBUG : turn off debugging for a faster executable
 -s TOTAL_MEMORY=67108864 : Make sure we have enough memory; in this case reserve 64 MB
 --js-library ../../source/web/library_emp.js : Load Empirical JS functions that we might need.
 -s EXPORTED_FUNCTIONS="['_main', '_empCppCallback']" : Make sure we can run the C++ functions
    main() and _empCppCallback() from Javascript, to facilitate two-way communication.
 -s NO_EXIT_RUNTIME=1 : In most cases, we don't want our program to stop when main() finishes.

...finally we list the source file we are compiling ("Example.cc") and the output file that we
want to produce ("Example.js").  The majority of these flags shouldn't change from one
compilation to the next, other than chaning optimization to debugging options, which we'll
cover in the debugging guide.

To test the results, open "Example.html" in your web browser!


=== Controlling a web page: The Basics ===

To understand how most of the HTML widgets work we need only change the main code file; the
current HTML file and compiler options can be left the same.

As indicated by our starting point, text can be streamed into an HTML document in a similar
way to an output stream in the standard library.  For example, we can update our main function
to mix text and variables:

  int main() {
    int x = 5;
    doc << "<h1>Hello World!</h1>";
    doc << "x = " << x << ".<br>";
  }

In additional to regular variables, emp::Document (and other Empirical web containers) can also
take a range of Empirical Widgets.

  void Ping() { doc << "Ping! "; }
  int main() {
    int x = 5;
    doc << "<h1>Hello World!</h1>";
    doc << "x = " << x << ".<br>";
    
    // Insert an image (in place)
    doc << UI::Image("url.goes.here") << "<br>";

    // Create a button and then insert it.
    UI::Button my_button( Ping, "Click me!" );
    doc << my_button;
  }

Notice now that you not only have a pretty picture, but you also have a button that will add
new text on to the screen each time it's clicked.

But what if we want to update existing content?  We can do this in two ways: either by marking
a variable (or function) as "Live" or by simply changing a widget that is already on the
screen.


=== "Live" Variables and Functions ===

Anything sent to a webpage that is inside a UI::Live( ) function will always have its most current
value used whenever that portion of the page is redrawn.  For example, let's make our button
modify the value of x and redraw it.

  int x = 5;
  int main() {
    doc << "<h1>Hello World!</h1>";
    doc << "Original x = " << x << ".<br>";
    doc << "Current x = " << UI::Live(x) << ".<br>";
    
    // Create a button to modify x.
    UI::Button my_button( [](){ x+=5; doc.Redraw(); }, "Click me!" );
    doc << my_button;
  }

Notice that we also moved x to be a global variable.  This is because if it were local to main()
it would be freed as soon as main ended.  We're also using a labda this time instead of a
previously defined function.  Either optioin is fine.

Try clicking on the button -- you'll see that x will be updated, and then the document is
signaled that it needs to redraw, so the change is reflected on the screen.  Note that we didn't
actually need to redraw the entire document to update x, just the Text widget it is in; we'll
talk more about how to do that below.

Of course, we can put a function in the UI::Live() and that function will be called each time
the containing Widget is redrawn.

  int x = 5;
  int main() {
    doc << "<h1>Hello World!</h1>";
    doc << "Original x = " << x << ".<br>";
    doc << "Current x = " << UI::Live(x) << ".<br>";
    doc << "x/5 = " << UI::Live( [](){ return x/5; } ) << ".<br>";
    
    // Create a button to modify x.
    UI::Button my_button( [](){ x+=5; doc.Redraw(); }, "Click me!" );
    doc << my_button;
  }

Of course, we need to be able to modify Widgets in addition to variables; fortunately this is
easy as well.




?: Re-attaching to a previously defined widget.

10: Controling CSS
11: Tables
12: Canvas
13: TextAreas
14: The Text Widget extras (specifying, closing, modifying, etc.)


?: Listeners and Capturing input events
?: Working with keypresses

12: Customized Divs
14: Uploading files
?: Interfacing between HTML and Empirical
?: Using JSWrap

?: Freezing and Activating Widgets
?: Animations
